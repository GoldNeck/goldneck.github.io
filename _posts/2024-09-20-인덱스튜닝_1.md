---
layout: post
title:  "인덱스 튜닝 테이블 랜덤 액세스"
summary: "SQL이 참조하는 컬럼을 인덱스가 모두 포함하지 않으면, 인덱스 스캔 후 테이블 액세스가 발생한다."
author: goldtree
date: '2024-09-20 11:22:27 +0530'
category: 'sql_tuning'
tags: DB
#thumbnail: /assets/img/posts/index_3.jpg
keywords: 인덱스, ROWID, 랜덤 액세스, 테이블 액세스
usemathjax: false
permalink: /blog/3index-1/
---

## 3장 인덱스 튜닝

## 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스

SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스 스캔 후 테이블 액세스함

“TABLE ACCESS BY INDEX ROWID”

검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서  테이블 레코드 찾아가기 위한 ROWID 를 얻는다.

인덱스 ROWID는 물리적 주소보단 논리적 주소에 가까움. 물리적으로 직접 연결되지 않고 테이블 레코드 찾기 위한 논리적 주소 정보를 가지고 있다.

색인 = ROWID

**메인메모리와 비교**

메인 메모리 DB : 데이터를 모두 메모리에 놓고 메모리 통해 I/O를 수행하는 DB

잘 튜닝된 OLTP성 데이터베이스 시스템은 버퍼캐시 히트율이 99% 이상이다. 디스크 경유하지 않고 메모리에서 읽는다.

인덱스 ROWID가 가리키는 테이블 블록을 버퍼캐시에서 찾아보고 못찾으면 디스크 블록을 읽는다.

### 3.1.2 인덱스 클러스터링 팩터

클러스터링 팩터(CF)는 ‘군집성 계수’ 

특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도

CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다. 

### 3.1.3 인덱스 손익분기점

인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다. 읽어야 할 데이터가 읽어야할 일정량을 넘는 순간, 테이블 전체 스캔보다 오히려 느려짐.

Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 ‘인덱스 손익분기점’이라 함

Table Full Scan 성능은 일정함. 인덱스를 이용해 테이블 액세스할 때는 몇건을 추출하느냐에 따라 성능이 달라진다. 추출건수가 많을 수록 느려짐.

**인덱스 테이블 액세스가 Table Full Scan보다 느려지는 요인**

1. **Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID 경우 랜덤 엑세스 방식이다**
2. **Table Full Scan은 Multiblock I/O 이고, 인덱스 ROWID는 Single Block I/O이다.** 

손익분기점은 5~20% 낮은 수준에서 결정됨.

**온라인 프로그램 튜닝 | 배치 프로그램 튜닝**

온라인 프로그램은 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는것이 중요. **NL방식이 유리**

배치 프로그램은 대량 데이터를 읽고 갱신하하므로 항상 전체범위 처리 기준으로 튜닝해야한다, 처리대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표. **Full Scan과 해시 조인이 유리**

초대용량 테이블을 Full Scan하면 상당히 오래기다려야하고 시스템에 주는 부담도 많음. 따라서 배치 프로그램에서는 파티션을 활용 전략이 중요한 튜닝 요소이고, 병렬 처리까지 더할 수 있으면 좋다.

**인덱스는 모든 성능 문제를 인덱스로 해결하면 안되고, 큰 테이블에서 적은 일부 데이터를 찾고자 할때가 적합**

