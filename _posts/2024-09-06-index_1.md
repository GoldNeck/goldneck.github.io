---
layout: post
title:  "SQL의 파싱 최적화 과정"
summary: "SQL의 구조적, 집합적, 선언적 특성과 함께 SQL 파싱, 최적화, 실행계획 및 비용 개념"
author: goldtree
date: '2024-09-06 12:15:23 +0530'
category: 'sql_tuning'
tags: DB
thumbnail: /assets/img/posts/index_1.jpg
keywords: SQL 파싱, SQL 최적화, 옵티마이저, 실행계획, 비용(Cost), 옵티마이저 힌트
usemathjax: false
permalink: /blog/인덱스1/
---

# 인덱스


## 인덱스 구조 / 탐색

인덱스 수직적 탐색, 수평적 탐색 두 단계로 이루어짐.

### 2.1.1 인덱스 튜닝

데이터베이스 테이블에서 데이터를 찾는 방법

1. 테이블 전체를 스캔
2. 인덱스 이용

테이블 전체 스캔 관련해서는 튜닝요소 많지 않지만 인덱스 관련 튜닝요소는 매우 많음

**인덱스요 튜닝 핵심요소**

큰 테이블에서 소량 데이터를 검색할 때 사용하고, 온라인 트랜잭션 처리 시스템에서 검색을 주로 하므로 튜닝 중요

1. 인덱스 스캔 과정에서 비효율을 줄이는 것 (인덱스 스캔 효율화 튜닝)
2. 테이블 엑세스 횟수 줄이는 것 
    - 인덱스 스캔 후 테이블 레코드 엑세스 할 때 랜덤 I/O 사용 (랜덤 액세스 최소화 튜닝)
    

### 2.1.2 인덱스 구조

대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 엑세스 하기 위해 사용하는 오브젝트

인덱스 없이 데이터 검색하면 처음부터 끝까지 읽어야 하지만, 인덱스를 이용하면 일부분만 읽고 멈춤 범위 스캔 (Range Scan) 가능하다.

DBMS는 일반적으로 B*Tree 인덱스를 사용 

수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정

수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색

정렬된 레코드 중 조건에 만족하는 첫 번째 레코드 찾는 과정, **즉 인덱스 스캔 시작지점을 찾는 과정이다.**

루트 블록에서 시작해 브랜치 블록에 저장된 각 인데스 레코드는 하위 블록에 대한 주소 값을 갖음. 


💡 조건을 만족하는 레코드를 찾는 과정 X 조건을 만족하는 첫 번째 레코드 O


### 2.1.4 인덱스 수평적 탐색

 찾고자 하는 데이터가 안나타날때가지 인덱스 리프 블록을 수평적으로 스캔

수평적 탐색 하는 이유

1. 조건절을 만족하는 데이터를 모두 찾기 위해
2. ROWID를 얻기 위해

### 결합 인덱스 구조와 탐색

두 개 이상의 컬럼을 결합해서 인덱스를 만들 수 있다.

인덱스를 [고객명 + 성별] 로 구성하든 [성별 + 고객명] 으로 구성하든 인덱스 블록 개수가 똑같다. 인덱스 선두 컬럼 모두 “=” 조건으로 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수는 같아 성능도 똑같다.
